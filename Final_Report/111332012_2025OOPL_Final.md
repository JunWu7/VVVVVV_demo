# 2025 OOPL Final Report

## 組別資訊

組別：P45
組員：資工三 111332012 吳峻丞
復刻遊戲：VVVVVV Demo

## 專案簡介

### 遊戲簡介

《VVVVVV Demo》是一款獨特的 2D 平台遊戲，以「重力翻轉」機制為核心玩法。玩家將扮演船長 Viridian，因太空事故而困在異次元世界，必須在重重障礙中尋找並拯救失散的船員。

與傳統的橫向卷軸遊戲不同，本作的跳躍機制被重力翻轉取代，玩家只能左右移動並翻轉自身的重力方向。關卡設計充滿挑戰，包含尖刺陷阱、移動平台等元素，並且死亡後可以立即重生至最近的存檔點。

本作的關卡在 Demo 的部分包含兩大關: Space Station 、 Laboratory ，本專案僅復刻了其中的第一大關 —— Space Station。

### 組別分工

我是自己一個人一組，因此沒有分工的問題


### 遊戲規則

#### 基本操作

| 鍵位                  | 功能說明              |
|---------------------|-----------------------|
| A / ←               | 向左移動               |
| D / →               | 向右移動               |
| W / ↑ / S / ↓ / 空白鍵 | **ACTION 鍵**：翻轉重力 |
| Enter               | 開啟遊戲輔助功能選單     |

#### debug mode

| 鍵位  | 功能說明                                                         |
|-------|------------------------------------------------------------------|
| K     | 切換**無敵模式**：角色不會被敵人或陷阱殺死（再次按下以取消）       |
| N     | 切換**重力鎖定模式**：角色不會因重力上下移動（再次按下以取消）     |

---

#### 遊戲輔助功能（Enter 鍵）

按下 `Enter` 鍵可打開輔助選單，透過左右方向鍵切換功能：

1. **MAP**  
   顯示玩家目前所在地圖及已經造訪的地圖。

2. **CREW**  
   顯示已救出的隊員（*Demo 版尚無實際功能*）。

3. **STATS**  
   顯示統計資訊：
   - 已收集寶物數
   - 死亡次數
   - 遊戲時間

4. **SAVE**  
   存檔功能（*Demo 版不提供*）。

---

#### 遊戲目標與玩法

- 利用移動與翻轉重力，躲避敵人與陷阱。
- 途中盡量收集寶物。
- 當進入 **最後一個房間** 後，按下 `Enter` 鍵會播放一小段片段。
- 欲關閉遊戲，請在片段播放完畢後按下 **ACTION 鍵**（`W` / `↑` / `S` / `↓`）。

---

#### 特殊機關說明

- **移動平台**：可站立，其會持續移動，玩家會隨之移動。
- **流沙地板**：站立一段時間後會**消失**，請小心使用。

### 遊戲畫面

[![report-img-1.jpg](https://i.postimg.cc/HWqmfKDN/report-img-1.jpg)](https://postimg.cc/6TfFZMQV)
[![report-img-2.jpg](https://i.postimg.cc/9FH3x7y5/report-img-2.jpg)](https://postimg.cc/t7kmJ7r2)
[![report-img-3.jpg](https://i.postimg.cc/NjQ3tvNd/report-img-3.jpg)](https://postimg.cc/7fQs1drz)
[![report-img-4.jpg](https://i.postimg.cc/7LWdSGqR/report-img-4.jpg)](https://postimg.cc/067VsNMG)
[![report-img-5.jpg](https://i.postimg.cc/MTf456Tp/report-img-5.jpg)](https://postimg.cc/LYRN6MLc)

## 程式設計
### 程式架構

在這次專案中，我將整體程式結構分為三大模組：玩家控制模組、關卡管理模組、以及地圖統計模組。
其中玩家控制模組負責處理角色的移動、翻轉；關卡管理模組集中控制遊戲內的所有互動物件，包括陷阱、敵人、儲存點、平台與寶物等；地圖統計模組則負責地圖的顯示切換以及玩家的統計資訊（如死亡次數、蒐集進度與遊戲時間）的呈現。

整體架構中各模組皆繼承自 Util::GameObject 並以元件化方式設計。

[![code.jpg](https://i.postimg.cc/h4T4Pgrn/code.jpg)](https://postimg.cc/Lh4FNcwQ)

### 程式技術

在程式實作過程中，有兩個我認為特別具挑戰性、也花費最多心力的核心功能實作，以下將針對這兩個部分進行說明。

### A. 可通行區域遮罩系統

在平台類遊戲中，角色行走的邏輯需要與場景的碰撞區域完全吻合，否則會發生角色穿牆、掉出地圖等錯誤。為了解決這個問題，本遊戲導入了「可通行區域遮罩系統」，讓角色的移動能夠自動對應到地圖圖片的實際可通行區域，減少額外標記區域的開發負擔。

本系統的運作方式如下：

1. **圖片區分設計**：每張地圖都區分為「背景圖片」與「前景圖片」。前景圖片才是真正用來與角色互動的場景。背景圖純粹為裝飾用途，角色不會與其有互動。

2. **遮罩生成機制**：初始化時，系統會將所有前景圖載入，並針對每一個像素讀取其透明通道。若該像素為透明，則代表該位置可通行；若為不透明，則視為障礙物。這些資訊會被轉換成布林陣列，形成「可通行遮罩」。

3. **遮罩資料儲存**：每個地圖對應一組遮罩資料，並以關卡 ID 作為 key，儲存在遮罩對應表中。這些遮罩資料只需初始化時建立一次，日後直接查表即可。

4. **角色移動判定**：每次角色移動時，會先根據當前地圖與欲移動位置查詢遮罩表，確認是否為可通行的區域。若不允許通行，則直接取消本次移動，避免角色進入非法位置。

這個系統大幅簡化了地圖碰撞設計的流程，只需依據圖像的透明與否判斷可行走範圍，免去了手動框選碰撞區的麻煩，也避免了程式中硬編碼碰撞邏輯的情況，讓整體地圖邏輯更容易維護與擴充。

以本專案為例，每張前景地圖皆搭配一張 `.png` 圖片，其中透明區域即為可行走範圍。在初始化階段，程式透過 `ImageLoader` 逐像素分析透明度，自動產生每張地圖的遮罩資料。當角色預備移動時，系統會呼叫 `LevelManager::isMoveAble(x, y)` 檢查該位置在遮罩中的值，若為不可通行則取消移動。因此即便新增地圖，只需繪製正確的透明區域即可自動完成碰撞區域的建立，完全不需手動編寫碰撞邏輯。


---

### B. 關卡資料表驅動的動態場景建立系統

在遊戲中，每一張地圖都包含了豐富的互動物件與場景元素，例如陷阱、敵人、流沙、移動平台、寶物等。若要為每張地圖手動編寫建置邏輯，將導致程式高度重複且難以維護。為了解決這個問題，我設計了一套「關卡資料表驅動的場景生成系統」，透過資料表描述所有地圖特性，再由程式自動完成地圖與物件的生成。

此系統的流程如下：

1. **建立資料表結構**：每張地圖在資料表中皆對應一筆資料，包含：
   - 圖片名稱（前景與背景）
   - 四個方向的鄰接地圖 ID
   - 是否含有特定元素（陷阱、敵人、寶物…）
   - 這些元素的詳細位置、屬性

2. **邊界觸發地圖切換**：當角色碰觸地圖邊界（上、下、左、右）時，系統會根據資料表中對應的鄰接地圖 ID 載入下一張地圖的資料，進行地圖切換。

3. **場景自動生成**：地圖切換後，系統會根據資料表的設定，依序生成該地圖所需的各類物件（如陷阱、敵人、流沙、平台等），並放入對應的容器中統一管理。原本上一張地圖的物件則會自動銷毀清除，避免資源浪費。

4. **統一的互動處理**：在遊戲進行中，角色會與這些動態產生的物件互動，例如踩到陷阱會死亡、碰到寶物會收集、接觸儲存點會存檔等等，所有互動判定皆由容器中的物件進行碰撞檢查與回應。

此技術的優點在於：

- 所有地圖資料集中管理，只需修改資料表即可新增或修改地圖
- 每張地圖的場景與物件生成邏輯高度統一，減少重複程式碼

整體來說，此技術使得本遊戲具備高可擴充性，即便未來新增十數張地圖，也只需編寫對應資料表項目即可自動生成完整關卡，實現快速建構大量場景的需求。

以本專案為例，每張地圖的資訊皆寫在 `LevelInfoTable` 裡，當角色觸碰邊界時，系統會查詢 `LevelData.leftWall / rightWall / upWall / downWall` 取得鄰接地圖的 ID，並切換當前地圖，呼叫 `setLevel()` 載入新的圖片與物件。新地圖的陷阱、敵人、平台等會依 `LevelData` 自動產生並存入 vector，例如 `std::vector<std::shared_ptr<Trap>> m_Traps` 等。這些設計使得主程式中無需硬編碼關卡邏輯，只需更新資料表即可支援新地圖。

## 結語

### 問題與解決方法

在本次實作中，過程中遭遇了數個技術上的瓶頸，這些問題雖然帶來挑戰，但也促使我對遊戲架構與效能優化有更深入的理解。以下列出三項較為關鍵的問題及對應的解決方式：

#### 第一個問題：遮罩載入效能瓶頸

在設計角色碰撞系統時，我原本預期在每次切換關卡後再動態載入該關卡對應的遮罩資料。然而實際測試後發現，這種方式在讀取遮罩圖像並轉換為可行走遮罩（透明即可通行）時，常需數秒鐘才能完成，嚴重影響遊戲體驗。

為了解決這個效能問題，我改為在 `LevelManager` 初始化時，就一次性預載入所有關卡的遮罩資料。這樣可以保證每次換圖時幾乎不需要額外等待，改善了整體遊戲的流暢度。

不過此方式的代價是啟動時需一次性加載 25 張遮罩圖片，導致初期啟動時間拉長，並佔用較多記憶體。這在 Demo 中是可接受的，但若關卡數量倍增，將不再適用。

這個系統大幅簡化了地圖碰撞設計的流程，只需依據圖像的透明與否判斷可行走範圍，免去了手動框選碰撞區的麻煩，也避免了程式中硬編碼碰撞邏輯的情況，讓整體地圖邏輯更容易維護與擴充。

#### 第二個問題：遊戲素材截取與轉換的挑戰

本遊戲的視覺素材來源為原作 VVVVVV 的圖像資源，但因為本專案的開發平台與解析度與原作不同，無法直接套用資源，因此需額外進行素材擷取與轉換。

我透過他人的遊玩影片與畫面擷取工具，逐幀擷取各關卡的遊戲畫面，再使用圖像編輯軟體手動將角色、陷阱、地圖等圖層進行分離。此外，為了建立碰撞遮罩，我將角色互動圖層另存為透明 PNG，作為布林遮罩的依據；而原始背景則獨立為不具互動性的裝飾圖層。

整體過程雖繁瑣，但讓我更加熟悉圖像處理工具，也加深了對關卡結構的理解。

#### 第三個問題：像素級碰撞導致效能問題

在初期的碰撞系統設計中，我嘗試實作像素級的透明度判斷，即判定物體與角色之間是否有非透明像素重疊，以作為判斷是否發生碰撞的依據。這種方法理論上非常精確，但實測結果卻顯示在遊戲中導致明顯掉幀與畫面延遲。

在評估資源消耗後，我選擇回歸較常見的 AABB（Axis-Aligned Bounding Box）碰撞箱實作方式。透過定義每個物件與角色的邊界矩形，進行簡單快速的碰撞檢查，成功解決效能瓶頸。

雖然碰撞精度略有降低，但實際遊戲體驗中並不明顯，且極大地提升了整體流暢度，為後續機制開發與除錯提供了穩定的基礎。


### 自評

| 項次 | 項目                   | 完成 |
|------|------------------------|-------|
| 1    | 完成專案權限改為 public |  V  |
| 2    | 具有 debug mode 的功能  | V   |
| 3    | 解決專案上所有 Memory Leak 的問題  |  V  |
| 4    | 報告中沒有任何錯字，以及沒有任何一項遺漏  |  V  |
| 5    | 報告至少保持基本的美感，人類可讀  | V  |

### 心得

這學期是我第一次嘗試製作遊戲，過程中學習到了如何在特定的框架下進行遊戲設計。透過這次實作，我得以從程式設計者的角度，重新思考自己曾經接觸過的遊戲內容，並理解其背後所蘊含的設計邏輯與技術手法。

在開發過程中，AI 的輔助扮演了關鍵的角色，不論是在問題的思考、程式撰寫，甚至是架構調整的過程中，都大幅提升了開發效率。我認為，AI 不僅是支援遊戲開發的強大工具，更是促進所有程式開發流程的重要助力。若是沒有 AI 的幫忙，獨立完成這份專案對我來說可能需要花上數倍的時間；但如今有了這項協助，即使是一人一組進行開發，也不再是一件遙不可及的任務。

整個開發過程中，從遇到問題、思考問題、嘗試解決，到最終成功排除錯誤，每一個環節都讓我獲得了寶貴的經驗與成就感。


### 貢獻比例        

因為整個專案是由我一人開發，因此我自己的占比是 100%